def query(self, question: str, top_k: int = 5) -> Dict[str, Any]:
        try:
            logger.info(f"쿼리 시작: {question}")
            
            # 먼저 컬렉션에 문서가 있는지 확인
            try:
                collection_info = self.qdrant_client.get_collection(self.collection_name)
                points_count = collection_info.points_count
                logger.info(f"컬렉션 문서 수: {points_count}")
            except Exception as e:
                logger.warning(f"컬렉션 확인 실패: {e}")
                points_count = 0
            
            # 문서가 없으면 바로 Claude에게 질문
            if points_count == 0:
                logger.info("RAG 문서 없음 - 일반 대화 모드")
                message = HumanMessage(content=question)
                response = self.llm.invoke([message])
                
                return {
                    "status": "success",
                    "answer": response.content,
                    "hit_info": [],
                    "context_used": 0,
                    "mode": "general"
                }
            
            # 문서가 있으면 RAG 검색
            query_embedding = self.embeddings.embed_query(question)
            
            # Qdrant 검색
            search_results = self.qdrant_client.search(
                collection_name=self.collection_name,
                query_vector=query_embedding,
                limit=top_k
            )
            
            # 검색 결과가 없거나 유사도가 낮으면 일반 대화
            if not search_results or (search_results and search_results[0].score < 0.5):
                logger.info("관련 문서 없음 - 일반 대화 모드")
                message = HumanMessage(content=question)
                response = self.llm.invoke([message])
                
                return {
                    "status": "success",
                    "answer": response.content,
                    "hit_info": [],
                    "context_used": 0,
                    "mode": "general"
                }
            
            # RAG 모드: 문서 컨텍스트 활용
            context_chunks = []
            hit_info = []
            
            for idx, result in enumerate(search_results):
                if result.score >= 0.5:  # 유사도 임계값
                    context_chunks.append(result.payload["text"])
                    hit_info.append({
                        "rank": idx + 1,
                        "file_name": result.payload["file_name"],
                        "score": round(result.score, 4),
                        "chunk_index": result.payload["chunk_index"]
                    })
            
            if context_chunks:
                context = "\n\n".join(context_chunks)
                
                prompt = f"""다음 문서를 참고하여 질문에 답변하세요.

참고 문서:
{context}

질문: {question}

답변:"""
                
                logger.info(f"RAG 모드 - {len(context_chunks)} chunks 사용")
            else:
                # 유사도가 낮으면 일반 대화
                prompt = question
                logger.info("유사도 낮음 - 일반 대화 모드")
            
            message = HumanMessage(content=prompt)
            response = self.llm.invoke([message])
            
            logger.info("쿼리 완료")
            
            return {
                "status": "success",
                "answer": response.content,
                "hit_info": hit_info,
                "context_used": len(context_chunks),
                "mode": "rag" if context_chunks else "general"
            }
            
        except Exception as e:
            logger.error(f"쿼리 실패: {e}", exc_info=True)
            
            # 에러 발생 시에도 일반 대화로 폴백
            try:
                logger.info("에러 발생 - 일반 대화로 폴백")
                message = HumanMessage(content=question)
                response = self.llm.invoke([message])
                
                return {
                    "status": "success",
                    "answer": response.content,
                    "hit_info": [],
                    "context_used": 0,
                    "mode": "fallback",
                    "note": f"RAG 검색 실패로 일반 대화 모드로 전환: {str(e)}"
                }
            except Exception as fallback_error:
                logger.error(f"폴백도 실패: {fallback_error}")
                return {
                    "status": "error",
                    "message": str(e),
                    "answer": f"죄송합니다. 오류가 발생했습니다: {str(e)}",
                    "hit_info": []
                }

